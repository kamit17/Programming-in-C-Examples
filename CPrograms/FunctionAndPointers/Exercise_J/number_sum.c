/*A 5-digit positive integer is entered through the keyboard, write a functionto calculate sum of digits of the 5-digit number:(1) Without using recursion(2) Using recursion*/#include <stdio.h>int digSum(int number){  int sum = 0;  while (number)  {    sum += number % 10;    number /= 10;  }  return sum;}/*This is the first function that calculates the sum of digits normally. main()calls this functions with the user entered number as the argument. Inside thefunction, I have devised a while loop. Why have I used 'number' in the condition?Since I will extract the last digit and add it to the running sum into thevariable 'sum', and also divide the number by 10 in each iteration. Once thenumber turns to be 0 on continuous dividing, the control comes out of the loop, and 'sum' is returned.*/int digSumRec(int number){  if (number)    return (number % 10 + digSumRec(number / 10));  else    return 0;}/*The statement which executes when the 'if' block condition is true, callsthe function digSumRec recursively, but the argument is passed as number /10instead of number. Thus as soon as number /10 returns zero, the if block is notexecuted. Moreover, the return statement in the if block does the addition part.It extracts the last digit from the 'number' and adds to it what is returned bythe recursive call to the procedure.*/int main(){  int number, sum = 0;  printf("\n\nEnter a 5 digit number: ");  scanf("%d", &number);  printf("\nSum without recursion: %d\nSum with recursion: %d\n\n",digSum(number),  digSumRec(number));  //system("pause");  return 0;}